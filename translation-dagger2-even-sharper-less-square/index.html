<!DOCTYPE html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

  	<meta property="og:title" content=" [译]更加强大的Dagger2 &middot;  Lowwor&#39;s Blog" />
  	<meta property="og:site_name" content="Lowwor&#39;s Blog" />
  	<meta property="og:url" content="http://lowwor.com/translation-dagger2-even-sharper-less-square/" />

    
  	<meta property="og:type" content="article" />

    <meta property="og:article:published_time" content="2016-01-06T21:41:57&#43;08:00" />

    
    <meta property="og:article:tag" content="翻译" />
    
    <meta property="og:article:tag" content="Android" />
    
    <meta property="og:article:tag" content="Dagger2" />
    
    

  <title>
     [译]更加强大的Dagger2 &middot;  Lowwor&#39;s Blog
  </title>

    <meta name="description" content="人的一切痛苦，本质上都是源于对自己无能的愤怒。" />

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="http://lowwor.com/images/favicon.ico">
	  <link rel="apple-touch-icon" href="http://lowwor.com/images/apple-touch-icon.png" />

    <link rel="stylesheet" type="text/css" href="http://lowwor.com/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="http://lowwor.com/css/nav.css" />
    <link rel="stylesheet" type="text/css" href="http://lowwor.com/css/tomorrow.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400|Inconsolata" />


    
        <link href="http://feeds.feedburner.com/..." rel="alternate" type="application/rss+xml" title="Lowwor&#39;s Blog" />
    
    <meta name="generator" content="Hugo 0.15" />

    <link rel="canonical" href="http://lowwor.com/translation-dagger2-even-sharper-less-square/" />

    
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-70800251-1', 'auto');
      ga('send', 'pageview');

    </script>
    

    
</head>
<body class="nav-closed">

  <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        
        
        
            
            <li class="nav-opened" role="presentation">
            	<a href="http://lowwor.com/">HOME</a>
            </li>
        
    </ul>
    
    
    <a class="subscribe-button icon-feed" href="http://feeds.feedburner.com/...">Subscribe</a> </div>
    
</div>
<span class="nav-cover"></span>


 <div class="site-wrapper">




<header class="main-header post-head no-cover">
  <nav class="main-nav clearfix">


  
  
      <a class="menu-button" href="#"><span class="burger">&#9776;</span><span class="word">Menu</span></a>
  
  </nav>
</header>



<main class="content" role="main">




  <article class="post post">

    <header class="post-header">
        <h1 class="post-title">[译]更加强大的Dagger2</h1>
        <small></small>

        <section class="post-meta">
        
          <time class="post-date" datetime="2016-01-06T21:41:57&#43;08:00">
            Jan 6, 2016
          </time>
        
         
          <span class="post-tag small"><a href="http://lowwor.com/tags/%E7%BF%BB%E8%AF%91/">#翻译</a></span>
         
          <span class="post-tag small"><a href="http://lowwor.com/tags/android/">#Android</a></span>
         
          <span class="post-tag small"><a href="http://lowwor.com/tags/dagger2/">#Dagger2</a></span>
         
        </section>
    </header>

    <section class="post-content">
      

<blockquote>
<ul>
<li>原文链接 : <a href="https://blog.gouline.net/2015/05/04/dagger-2-even-sharper-less-square/">Dagger 2: Even sharper, less square</a></li>
<li>原文作者 : <a href="https://github.com/mgouline">Mike Gouline</a></li>
<li>译文出自 : <a href="http://www.devtf.cn">开发技术前线 www.devtf.cn</a></li>
<li>转载声明: 本译文已授权<a href="http://toutiao.io/download">开发者头条</a>享有独家转载权，未经允许，不得转载!</li>
<li>译者 : <a href="https://github.com/lowwor">lowwor</a></li>
<li>校对者: <a href="https://github.com/maoruibin">maoruibin</a><br /></li>
<li>状态 :  完成</li>
</ul>
</blockquote>

<p>著名的依赖注入库Dagger的2.0版本变为生产版本只是一个时间问题，这似乎给了我一个写一篇关于它的文章的好理由。</p>

<h2 id="dagger-1:6cb4c08defbc648acc6094d1fc591a9d">Dagger 1</h2>

<p>在这里，先做一个小小的历史回顾，Dagger是由<a href="https://corner.squareup.com/">Square</a>公司的几个十分优秀的开发人员在2012年创建的，他们觉得将依赖注入应用到Java中是一个非常棒的点子，但是却觉得当时使用的<a href="https://github.com/google/guice">Guice</a>库（当时的标准）的速度稍微有点慢。所以，他们开发了一个依赖于基于注解的代码生成（JSR-330），拥有着和Guice相似的API，但是性能更强、更加灵活的库。</p>

<p>Dagger的工作原理就是通过声明一些module，这些module里包括了所有你想要注入的依赖的提供者方法（provider method），
把这些module加载到一个对象图谱（object graph）里，最终将图谱中的内容根据需要注入到对象（target）中。
足够简单的结构（当然实现起来还是不那么简单的）有利于开发者解耦他们的代码,并且通过把初始化代码移动到由库自动生成的injector中,从而删掉每个类开始的地方那些丑陋的工厂类初始化代码。</p>

<p>然而，伴随着明显的优点（这些优点足以让大部分的Android开发者选择Dagger作为他们开发新项目中选择使用的第一个库），也存在着一些明显的问题，都是一些不可以简单地被一个或者两个的pull request就解决掉的问题，因为这些问题都是与整个底层架构相关的。</p>

<ul>
<li><p>图谱（Graph）是在运行时构建的    -影响性能，尤其是在频繁请求的用例中（后台服务器场景），</p></li>

<li><p>使用了反射（比如说  用<code>Class.forName()</code>来获取已经生成的类型） - 使得生成的代码难以跟踪，同时ProGuard配置文件的编写成了噩梦</p></li>

<li><p>生成的代码不美观 -特别是与那些人手写的工厂类初始化方法相比较时，这一点尤其明显。</p></li>
</ul>

<p>因而，在Github的问题跟踪系统中，由于上述问题导致的一些issues，都被标记为“它就是这样的，这个问题会在Dagger2中解决”</p>

<h2 id="dagger-2:6cb4c08defbc648acc6094d1fc591a9d">Dagger 2</h2>

<p>时间快进到现在，Google的core libraries团队（<a href="https://github.com/google/guava">Guava</a>的创造者）与原来的Square的创建者一起推出了新一代的Dagger，并在一个月内就发布了生产版本</p>

<p>新的release版本，像之前所承诺的一样，解决了老版本的许多问题：</p>

<ul>
<li><p>不再使用反射 所有东西都是通过明确的方法调用来完成的（不需要配置ProGuard文件就可以正常混淆）</p></li>

<li><p>不再在运行时构建图表（graph） - 提高了性能，包括在单请求（per-request）用例中（据<a href="https://plus.google.com/+GregoryKick">Gregory Kick</a>说，在谷歌的搜索产品中，它的表现比以前快了13%）</p></li>

<li><p>可追溯的 - 生成的代码更优雅，同时没有使用到反射，使得代码可读性提高，并且容易跟踪</p></li>
</ul>

<h2 id="usage-用法:6cb4c08defbc648acc6094d1fc591a9d">Usage 用法</h2>

<p>虽然Dagger也可以用在任何的Java工程中，但是在示例代码中，我们将专注于它在Android平台上的应用。不过，这些代码都可以很容易的就被改写，以用于其它地方，比如说，改写为服务器后端相关的代码。</p>

<h2 id="module:6cb4c08defbc648acc6094d1fc591a9d">Module</h2>

<p>Dagger2中基本保持不变的部分是module。你仍然需要在这里定义可被注入的依赖的提供者方法（provider methods）。比如说，我们需要注入的是<code>SharedPreferences</code>对象。</p>

<pre><code>@Module
public class ApplicationModule {  
private Application mApp;

public ApplicationModule(Application app) {
    mApp = app;
}

@Provides 
@Singleton
SharedPreferences provideSharedPrefs() {
    return PreferenceManager.getDefaultSharedPreferences(mApp);
}
}
</code></pre>

<p>类似的，你可以提供（provide）其他的东西（并不是所有的，只是提供一些想法）</p>

<ul>
<li>Context</li>
<li>System services (e.g. LocationManager)</li>
<li>REST service (e.g. Retrofit)</li>
<li>Database manager (e.g. Realm)</li>
<li>Message passing (e.g. EventBus)</li>
<li>Analytics tracker (e.g. Google Analytics)</li>
</ul>

<h2 id="component:6cb4c08defbc648acc6094d1fc591a9d">Component</h2>

<p>眼尖的读者可能发现了在<code>@Module</code>注解中，<code>injects = {}</code>参数不见了，那是因为Dagger2不再需要用到这个参数了。取而代之的是，&rdquo;component&rdquo;的概念，component是用来连接module和要注入依赖的对象（target）之间的桥梁。</p>

<pre><code>@Singleton
@Component(modules = {ApplicationModule.class})
public interface ApplicationComponent {  
    void inject(DemoApplication app);
    void inject(MainActivity activity);
}
</code></pre>

<p>所以，你仍然需要注明（define）你要注入依赖的对象（target），但是，与之前不同的是，如果你现在不注明的话，在编译时就会提示&rdquo;cannot find method&rdquo;错误，而这个错误在以前，则是一个隐秘的运行时错误，只有在运行时才会报错。</p>

<h2 id="application-应用:6cb4c08defbc648acc6094d1fc591a9d">Application 应用</h2>

<p>下一步，我们要了解的是你的component的容器。具体的方式由你的应用来决定，你可以选择用更复杂的方式保存你的components，但是对于这个例子来说，一个简单的保存在application中的component就足以说明情况了。</p>

<pre><code>public class DemoApplication extends Application {  
private ApplicationComponent mComponent;

@Override 
public void onCreate() {
    super.onCreate();
    mComponent = DaggerApplicationComponent.builder()
                    .applicationModule(new ApplicationModule(this))
                    .build();
}

public ApplicationComponent getComponent() { 
    return mComponent;
}
}
</code></pre>

<p>这里没有什么新的东西：只是之前我们创建并初始化的的是对象图谱（<code>ObjectGraph</code>），而现在，我们则会创建并初始化对应的component。</p>

<p>注意：你很有可能会在某个时候想到这个问题，我在这先提前解释一下。上面例子中的<code>DaggerApplicationComponent</code>是一个编译时生成的类（命名方式是 <code>Dagger%COMPONENT_NAME%</code>），只要你对你的component做了改动，就需要重新编译工程，通过了，这个类才会被生成。所以，如果你找不到这个类，点击你的IDE的&rdquo;Rebuild Project&rdquo;，如果编译不出错的话，它就会出现了。类似的，<code>applicationModule()</code>方法对应于你的module的名字。</p>

<h2 id="injection-注入:6cb4c08defbc648acc6094d1fc591a9d">Injection 注入</h2>

<p>终于，经过前面几个部分为注入进行的准备后，我们来到了用到它们的地方了，我们要在activity中注入一个SharedPreferences对象。</p>

<pre><code>public class MainActivity extends Activity {  
@Inject SharedPreferences mSharedPrefs;

@Override 
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    ((DemoApplication) getApplication()).getComponent().inject(this);

    mSharedPrefs.edit().putString(“status”, “success!”).apply();
}
}
</code></pre>

<p>和期待的一样，<code>@Inject</code>注解的使用没有任何改变，只是注入本身发生了一点变化。</p>

<p>这里有一点小小的不便，是由于<code>inject()</code>方法是强类型关联的，这个我们在后面会讨论到。</p>

<p><strong>Named injections 命名注入</strong>
如果你有几个对象是同一类型的，比如说两个不同的<code>SharedPreferences</code>实例（可能是指向了不同的文件），这时候，我们可以怎么做？
这时候，我们就需要用到命名注入了。只要在module的提供者（provider）里像下面一样使用<code>@Named</code>注解</p>

<pre><code>@Provides 
@Named(“default”) 
SharedPreferences provideDefaultSharedPrefs() { … }

@Provides 
@Named(“secret”)
SharedPreferences provideSecretSharedPrefs() { … }  
</code></pre>

<p>在要注入的对象中，注入的方法是一样的</p>

<pre><code>@Inject @Named(“default”) SharedPreferences mDefaultSharedPrefs;
@Inject @Named(“secret”) SharedPreferences mSecretSharedPrefs;
</code></pre>

<p>很简单，没有什么好解释的，但是这是一个非常有用的用法，值得一提。</p>

<h2 id="lazy-injections-延迟注入:6cb4c08defbc648acc6094d1fc591a9d">Lazy injections 延迟注入</h2>

<p>说到性能，如果在一个要注入依赖的对象中，有很多不同的依赖需要被注入，有些依赖只会在某些特定的场景才会被用到（比如说 用户输入的时候）。在这种情况下，如果我们没有用到这个依赖，也要去注入的话，会导致资源的浪费，所以，我们可以选择用延迟注入（lazy injection）替代。</p>

<pre><code>@Inject Lazy&lt;SharedPreferences&gt; mLazySharedPrefs;

void onSaveBtnClicked() {  
    mLazySharedPrefs.get()
    .edit().putString(“status”, “lazy…”)
    .apply();
}
</code></pre>

<p>这里的意思是说，<code>mLazySharedPrefs</code>只有在第一次调用<code>get()</code>方法的时候才会被注入。之后所有的<code>get()</code>调用都会是同一个mLazySharedPrefs实例。</p>

<h2 id="provider-injections-注入提供者:6cb4c08defbc648acc6094d1fc591a9d">Provider injections 注入提供者</h2>

<p>最后一个诀窍，如果你是在一个全新的你可以完全掌控住的工程中，你想要实现这样的注入的话，你可能会考虑用其它方法来替代，比如说<a href="http://en.wikipedia.org/wiki/Factory_%28object-oriented_programming%29">工厂方法</a>。
但是，对于历史遗留代码来说，这个诀窍将会很有用。</p>

<p>想象这样一个场景，你需要创建一个对象的多个实例，而不是仅仅注入单个实例。在这时候，你需要注入一个提供者（<code>Provider&lt;T&gt;</code>）</p>

<pre><code>@Inject Provider&lt;Entry&gt; mEntryProvider;

Entry entry1 = mEntryProvider.get();  
Entry entry2 = mEntryProvider.get();  
</code></pre>

<p>在这个例子中，你的提供者（provider）会创建两个<code>Entry</code>对象的实例。有一点要注意的是，module中的实例如何创建完全是由你决定的</p>

<h2 id="annoyances-烦人的地方:6cb4c08defbc648acc6094d1fc591a9d">Annoyances 烦人的地方</h2>

<p>还好，我真的不能把这个部分叫做问题，因为都是一些不足以称为问题的东西。</p>

<p><strong>烦人的地方#1：</strong> 像是之前提到的，<code>inject()</code>方法与要注入的target，是强类型关联的。这对于debug来说很好，但是这对于我们希望在基类中实现注入的普遍做法变得复杂（如在 base activity，fragment等中）。</p>

<p>直觉上，你觉得应该在基类中创建一个<code>inject()</code>方法，但是，这样做的话，它就仅仅会注入那些在基类中声明的依赖，在他的子类中声明的依赖并不会被注入。</p>

<p>解决方法1：这也是我所使用的解决方案，就是在基类中声明一个抽象的注入方法来进行实际上的注入</p>

<pre><code>@Override
public void onCreate(Bundle savedInstanceState) {  
    super.onCreate(savedInstanceState);
    injectComponent(((DemoApplication) getApplication()).getComponent());
}

protected void injectComponent(ApplicationComponent component);  
</code></pre>

<p>然后在你的子类中实现这个方法</p>

<pre><code>
@Override
protected void injectComponent(ApplicationComponent component) {  
    component.inject(this);
}
</code></pre>

<p>与Dagger1相比，需要多写一个额外的方法，来实现同样的事情。但是为了可以在编译时查错，这个代价是完全值得的。</p>

<p>解决方法2：另一个选择就是利用反射。如果你看到反射就不想看下去的话，并不怪你：因为这也是Dagger2所提到的点，不利用反射。但是，如果你坚持要在基类中实现注入，而不想在子类中增加额外方法的话，请继续往下看。</p>

<p>这个解决方法简而言之就是要找到你要注入的类型所对应的<code>inject()</code>方法。</p>

<p>首先，你要将在component类中声明的所有方法对应上方法的参数类型来保存在缓存中（因为<code>inject()</code>方法只能有一个参数，所以只需保存第一个有一个参数的方法就行）</p>

<pre><code>// Keep the returned cache in some helper.
Map&lt;Class, Method&gt; buildCache() {  
    Map&lt;Class, Method&gt; cache = new HashMap&lt;&gt;();
    for (Method m : ApplicationComponent.class.getDeclaredMethods()) {
        Class[] types = m.getParameterTypes();
        if (types.length == 1) {
        cache.put(types[0], m);
        }
    }
return cache;
}
</code></pre>

<p>最后，你只要在需要注入依赖的对象（target）中调用<code>getClass()</code>，找到缓存中对应的方法，然后使用<code>invoke()</code>来调用这个方法就行了。</p>

<pre><code>// Use for injecting targets of any type.
void inject(ApplicationComponent component, Object target) {  
    Method m = cache.get(target.getClass());
    if (m != null) {
    m.invoke(component, target);
    }
}
</code></pre>

<p>在这里，我想重申一下,这个解决方法只是为了省几行代码，却对整个流程进行了过度的设计，我个人来说是不会这样做的，但是对于那些想把注入的过程隐藏在基类中，或者是在旧的代码中已经是这样做的人来说，或许会觉得这个方法是有用的。</p>

<h3 id="annoyance-2-烦人的地方2:6cb4c08defbc648acc6094d1fc591a9d">Annoyance #2:烦人的地方2：</h3>

<p>Component的实现类（比如说：<code>DaggerApplicationComponent</code>）只有在重新编译工程之后才能出现，同时如果在编译时出现任何与注入相关的错误的话，都会提示找不到这个类（换句话说，这个类没有被生成）。</p>

<p>我承认这虽然不是什么大问题，但是你会觉得这有点烦，至少在你刚开始使用Dagger2的那几个小时里会这样觉得，尤其是这几个小时还是你对component改动比较频繁的时候。因而，这个问题还是值得提一下的。</p>

<p>解决方法：据我所知，没有。</p>

<h2 id="conclusion-结论:6cb4c08defbc648acc6094d1fc591a9d">Conclusion 结论</h2>

<p>我不想在这里长篇大论的总结，所以我会尽可能说的简洁精练</p>

<p>Dagger2是否比原来的版本有明显的进步？是的，提升非常大。</p>

<p>是否还存在问题呢？是的，但是这些问题并没有严重到让你连试都不想试，甚至不会影响到你在生产环境的工程中使用它</p>

<h2 id="updates-更新:6cb4c08defbc648acc6094d1fc591a9d">Updates 更新</h2>

<p>2015-05-11: 根据Jake Wharton的评论，更正了对Dagger 1中反射使用的陈述。</p>

<h2 id="source-源码:6cb4c08defbc648acc6094d1fc591a9d">Source 源码</h2>

<p><a href="https://github.com/mgouline/android-samples/tree/master/dagger2-demo">Dagger 2 Demo</a> (GitHub)</p>

<h2 id="resources-资源:6cb4c08defbc648acc6094d1fc591a9d">Resources 资源</h2>

<p><a href="http://google.github.io/dagger/">Documentation</a>
<a href="https://www.youtube.com/watch?v=oK_XtfXPkqw">Video introduction</a> - by Gregory Kick (Google)</p>

    </section>


  <footer class="post-footer">


    

    





<section class="author">
  <h4><a href="http://lowwor.com/">Lowwor</a></h4>
  
  <p>I am a Android developer.</p>
  
  <div class="author-meta">
    <span class="author-location icon-location">Guangdong, China</span>
    <span class="author-link icon-link"><a href="http://lowwor.com">http://lowwor.com</a></span>
  </div>
</section>



    
<section class="share">
  <h4>Share this post</h4>
  <a class="icon-twitter" style="font-size: 1.4em" href="https://twitter.com/share?text=%5b%e8%af%91%5d%e6%9b%b4%e5%8a%a0%e5%bc%ba%e5%a4%a7%e7%9a%84Dagger2&amp;url=http%3a%2f%2flowwor.com%2ftranslation-dagger2-even-sharper-less-square%2f"
      onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
      <span class="hidden">Twitter</span>
  </a>
  <a class="icon-facebook" style="font-size: 1.4em" href="https://www.facebook.com/sharer/sharer.php?u=http%3a%2f%2flowwor.com%2ftranslation-dagger2-even-sharper-less-square%2f"
      onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
      <span class="hidden">Facebook</span>
  </a>
  <a class="icon-pinterest" style="font-size: 1.4em" href="http://pinterest.com/pin/create/button/?url=http%3a%2f%2flowwor.com%2ftranslation-dagger2-even-sharper-less-square%2f&amp;description=%5b%e8%af%91%5d%e6%9b%b4%e5%8a%a0%e5%bc%ba%e5%a4%a7%e7%9a%84Dagger2"
      onclick="window.open(this.href, 'pinterest-share','width=580,height=296');return false;">
      <span class="hidden">Pinterest</span>
  </a>
  <a class="icon-google-plus" style="font-size: 1.4em" href="https://plus.google.com/share?url=http%3a%2f%2flowwor.com%2ftranslation-dagger2-even-sharper-less-square%2f"
     onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
      <span class="hidden">Google+</span>
  </a>
</section>



    

<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'lowwor';
  var disqus_url = 'http:\/\/lowwor.com\/translation-dagger2-even-sharper-less-square\/';
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>




  </footer>
</article>

</main>
    <footer class="site-footer clearfix">
        <section class="copyright"><a href="">Lowwor&#39;s Blog</a> All rights reserved - 2016</section>
        
        <section class="poweredby">Proudly generated by <a class="icon-hugo" href="http://gohugo.io">HUGO</a>, with Rowwol theme modified from <a class="icon-theme" href="https://github.com/vjeantet/hugo-theme-casper">Casper</a></section>
        
    </footer>
    </div>
    <script type="text/javascript" src="http://lowwor.com/js/jquery.js"></script>
    <script type="text/javascript" src="http://lowwor.com/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="http://lowwor.com/js/index.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    
</body>
</html>

